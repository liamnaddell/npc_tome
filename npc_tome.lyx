#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{tikz}
\usetikzlibrary{graphs}
\usetikzlibrary{arrows}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0.25in
\topmargin 0.25in
\rightmargin 0.25in
\bottommargin 0.25in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
What is the point of this document?
\end_layout

\begin_layout Standard
This is supposed to serve as a reference guide for C63.
 When I took the course over the fall 2022 with Nick Cheng, I found it difficult
 to keep track of all the concepts and how they tie together.
 I found C63 to require EXTREME competence at the early material to continue
 succeeding in the course.
 I.e.
 If you don't understand the intricacies of turing machines (configurations),
 you will struggle the P, NP, and PSPACE language classes.
 Additionally, C63 requires a 
\series bold
HUGE 
\series default
mastery of B36 material.
 Many, many people (i.e.
 me) lost valuable points on the midterms and finals because of lacking
 B36 skills.
 I did WELL in B36 too.
 Additionally, the book we used (Sisper) was overly long winded and did
 a poor job of connecting the ideas it contains together in a coherent story.
 The point of this document is to prove most of the claims in the course
 and to document its proof techniques, that way it can serve as a reference
 for C63 topics.
 Sisper also leaves rigorous definitions as exercises to the reader, I tried
 not to.
 Feel free to message me over discord for corrections or for comments.
 I'd also be happy to help people out with the course.
 
\end_layout

\begin_layout Subsection
Credits:
\end_layout

\begin_layout Standard
All the ideas in this document other than my advice come from Michael Sisper
 and Nick Cheng, most of the proofs are copied from Sisper's book.
 
\end_layout

\begin_layout Subsection
What B36 skills should you review?
\end_layout

\begin_layout Itemize
Languages in b36 were defined using D/NFSA's, and PDA's, in this course,
 languages are defined similarly on turing machines, i.e.
 
\begin_inset Formula $L=\mathcal{L}\left(M\right)=\left\{ \left\langle w\right\rangle \vert\text{ M is a Turing Machine, }w\in\Sigma^{\star},\text{ M accepts w}\right\} $
\end_inset

.
 In plain english, 
\begin_inset Formula $\mathcal{L}\left(M\right)$
\end_inset

 is all the strings M accepts.
 
\end_layout

\begin_layout Itemize
When you are learning about co-NP, make 
\series bold
ABSOLUTELY SURE 
\series default
you are rock solid on your ability to take the complement of a language,
 including languages with implications
\end_layout

\begin_layout Itemize
Make sure you understand how to take the negation of a qualified boolean
 formula like 
\begin_inset Formula $\forall x_{1}\exists x_{2}[\left(x_{1}\vee x_{2}\right)\wedge\left(x_{1}\to x_{2}\right)]$
\end_inset

, also how to translate english sentences into boolean formulas.
 Nick Cheng has some additional notes on this topic from B36.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
What is the point of this course?
\end_layout

\begin_layout Standard
CSCC63 is fundamentally about classifying languages.
 The primary language classes are, Decidable, Recognisable, Co-Recognisable,
 P, NP, co-NP, NP-Complete, PSPACE, and NSPACE.
 
\end_layout

\begin_layout Subsection
Notation
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle x\right\rangle $
\end_inset

 denotes 
\begin_inset Quotes eld
\end_inset

The encoding of x
\begin_inset Quotes erd
\end_inset

.
 Encodings translate mathematical objects like sets into strings which can
 be fed as inputs to turing machines, or contained in languages as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula $L=\left\{ \left\langle M,w\right\rangle \vert\text{ M is a Turing Machine, \ensuremath{w\in\Sigma^{\star}}, After running M on w, M accepts }\right\} $
\end_inset


\end_layout

\begin_layout Section
What is a turing machine?
\end_layout

\begin_layout Standard
A turing machine is a model of computation.
 In C63, a Turing Machine will stand in for 
\begin_inset Quotes eld
\end_inset

Any algorithm
\begin_inset Quotes erd
\end_inset

.
 Any algorithm can be written as a turing machine, and in similar* running
 time and similar* memory usage.
 These are the beefiest automatons possible, no other automaton is more
 powerful than a turing machine, and the turing machine surpasses the DFSA,
 NFSA, and PDA in capabilities.
 This is because the turing machine has access to an infinite, addressable
 memory space, unlike PDA's which are only capable of addressing memory
 sequentially through the stack.
\end_layout

\begin_layout Subsection
What is it, like specifically though
\end_layout

\begin_layout Standard
A Turing Machine 
\begin_inset Formula $M=\left\langle Q,\Gamma,b,\Sigma,\delta,q_{0},F\right\rangle $
\end_inset

, with 
\series bold
FINITE
\series default
 states Q, A 
\series bold
FINITE 
\series default
set of Symbols which can appear on the tape 
\begin_inset Formula $\Gamma$
\end_inset

, an input alphabet 
\begin_inset Formula $\Sigma\subset\Gamma$
\end_inset

, a blank symbol 
\begin_inset Formula $b\in\Gamma$
\end_inset

, an initial state 
\begin_inset Formula $q_{0}\in Q$
\end_inset

, a set of final states 
\begin_inset Formula $F\subseteq Q$
\end_inset

, and a 
\series bold
FINITE 
\series default
transition function 
\begin_inset Formula $\delta$
\end_inset

, which encodes the transition labels.
 The diagrams which describe turing machines encode 
\begin_inset Formula $\delta$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
A very important note
\end_layout

\begin_layout Standard
Turing Machines, by design, are finite machines which encode finite algorithm
 descriptions.
 This means that the set of turing machines can be iterated through.
 Not only that, but turing machine encodings (
\begin_inset Formula $\left\langle Q,\Gamma,b,\Sigma,\delta,q_{0},F\right\rangle $
\end_inset

) can be fed to 
\series bold
OTHER TURING MACHINES
\series default
.
 This means we can write algorithms which process other algorithms.
 This is the fundamental proof tool for the course.
\end_layout

\begin_layout Subsubsection
Another very important note
\end_layout

\begin_layout Standard
Turing machines have 2 possible final states, accepting and rejecting.
 Unfortunately, turing machines also are able to loop infinitely.
 It will be proven later in these notes that there is 
\series bold
NO GENERAL ALGORITHM
\series default
 for determining whether or not a given turing machine will loop on a given
 input.
 
\end_layout

\begin_layout Part
How to determine if languages are Recognisable, Decidable, or Co-recognisable.
 
\end_layout

\begin_layout Section
The first language classifications: Recognisable and Decidable languages
\end_layout

\begin_layout Subsection
The definition of recognisability using Enumerators
\end_layout

\begin_layout Subsubsection
What's an enumerator?
\end_layout

\begin_layout Standard
An enumerator is a special kind of turing machine with two tapes, the work
 tape, and the print tape.
 There is also a specialized 
\begin_inset Quotes eld
\end_inset

print
\begin_inset Quotes erd
\end_inset

 state which will 
\begin_inset Quotes eld
\end_inset

print
\begin_inset Quotes erd
\end_inset

 the contents of the print tape to an attached theoretical printer.
 Using this definition, let E be an enumerator, 
\begin_inset Formula $\mathcal{L}\left(E\right)=\left\{ x\vert\text{x is printed by E at some point in its runtime}\right\} $
\end_inset

.
 Note, enumerators can halt or loop forever, this does show up in exam questions
, enumators may also repeat inputs, this can be useful for lazy algorithm
 writers.
 
\end_layout

\begin_layout Subsubsection
The actual definition
\end_layout

\begin_layout Standard
A language L is recognisable if and only if there exists an enumerator E
 st 
\begin_inset Formula $\mathcal{L}\left(E\right)=L$
\end_inset

.
 In english, this is written as, 
\begin_inset Quotes eld
\end_inset

E enumerates L
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection
Steps for proving a language is recognisable using enumerators
\end_layout

\begin_layout Standard
1.
 Describe an enumerator E 
\end_layout

\begin_layout Standard
2.
 Prove that every 
\begin_inset Formula $x\in L$
\end_inset

 is in 
\begin_inset Formula $\mathcal{L}\left(E\right)$
\end_inset


\end_layout

\begin_layout Standard
3.
 Prove that every 
\begin_inset Formula $x\not\in L$
\end_inset

 is NOT in 
\begin_inset Formula $\mathcal{L}\left(E\right)$
\end_inset


\end_layout

\begin_layout Subsection
The definition of recognisability using regular turing machines
\end_layout

\begin_layout Standard
Given a regular turing machine D and an arbitrary language L, D recognises
 L if and only if
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $w\in L$
\end_inset

, D accepts w
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $w\not\in L$
\end_inset

, D does not accept w (D may reject 
\series bold
OR LOOP ON 
\series default
w)
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
A recognisable language per this definition is a language where some turing
 machine recognises it.
\end_layout

\begin_layout Subsection
The definition of co-recognisability
\end_layout

\begin_layout Standard
Co-recognisable languages are languages who's complements are recognisable.
 I.e.
 L is co-recognisable if and only if 
\begin_inset Formula $\overline{L}$
\end_inset

 is recognisable
\end_layout

\begin_layout Subsubsection
Proving a language L is co-recognisable
\end_layout

\begin_layout Enumerate

\series bold
CAREFULLY, MATICULOUSLY, and EXACTLY 
\series default
take the language complement of L to obtain 
\begin_inset Formula $\overline{L}$
\end_inset

, this is MUCH HARDER than you think it is
\end_layout

\begin_layout Enumerate
Write a recogniser for 
\begin_inset Formula $\overline{L}$
\end_inset

 and prove it is a recogniser using any of the techniques above.
 
\end_layout

\begin_layout Subsection
The definition of decidability
\end_layout

\begin_layout Standard
Decidable languages are langauges which are 
\series bold
BOTH
\series default
 recognisable and co-recognisable.
 Proving a language L is decidable requires using both proof techniques
 for recognisability and co-recognisability.
 
\end_layout

\begin_layout Section
Showing that languages are NOT recognisable or decidable using MAPPING REDUCTION
S!
\end_layout

\begin_layout Standard
The previous section detailed how to prove that a language is recognisable,
 the issue is that we have no techniques to show languages are NOT recognisable.
 The techique built in this chapter is called 
\begin_inset Quotes eld
\end_inset

The mapping reduction
\begin_inset Quotes erd
\end_inset

.
 This technique is extremely subtle and confusing, with AWFUL NOTATION which
 I have a whole rant about later in this document.
 Mapping reductions require us to find un-recognisable languages using other
 techniques first, which we must do before defining mapping reductions.
 To find un-recognisable languages, we must first find an un-decidable language.
 
\end_layout

\begin_layout Subsection
The first undecidable language 
\begin_inset Formula $A_{TM}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A_{TM}=\left\{ \left\langle M,w\right\rangle \vert\text{ M is a TM and M accepts w}\right\} $
\end_inset


\end_layout

\begin_layout Subsubsection
Showing 
\begin_inset Formula $A_{TM}$
\end_inset

 is recognisable
\end_layout

\begin_layout Quote
U=
\begin_inset Quotes erd
\end_inset

On input 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

, where M is a TM and w is a string:
\end_layout

\begin_deeper
\begin_layout Quote
1.
 Simulate M on input w
\end_layout

\begin_layout Quote
2.
 If M ever enters its accept state, accepts, else if M enters the reject
 state, reject
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
For completeness, I will also prove that U is a recogniser for 
\begin_inset Formula $A_{TM}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\left\langle M,w\right\rangle \in A_{TM}$
\end_inset

, we know M accepts w.
 Therefore, U will accept 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\left\langle M,w\right\rangle \not\in A_{TM}$
\end_inset

, we know M does not accept w, therefore U will not accept 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
Therefore, 
\begin_inset Formula $\left\langle M,w\right\rangle \in A_{TM}\iff\left\langle M,w\right\rangle \in\mathcal{L}\left(U\right)$
\end_inset

, showing U recognises 
\begin_inset Formula $A_{TM}$
\end_inset


\end_layout

\begin_layout Subsubsection
Showing 
\begin_inset Formula $A_{TM}$
\end_inset

 is NOT decidable
\end_layout

\begin_layout Standard
Assume that 
\begin_inset Formula $A_{TM}$
\end_inset

 is decidable for the purposes of contradiction.
 
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $A_{TM}$
\end_inset

 is decidable, there must exist a turing machine H which decides 
\begin_inset Formula $A_{TM}$
\end_inset

.
\end_layout

\begin_layout Standard
Now, construct a TM D as follows:
\end_layout

\begin_layout Quote
D=
\begin_inset Quotes erd
\end_inset

On input 
\begin_inset Formula $\left\langle M\right\rangle $
\end_inset

, where M is a TM:
\end_layout

\begin_deeper
\begin_layout Quote
1.
 Run H on input 
\begin_inset Formula $\left\langle M,\left\langle M\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Quote
2.
 Output the opposite of what H outputs.
 I.e.
 if H acc then rej, if H rej, then acc
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
D is constructed to behave as follows: 
\end_layout

\begin_layout Standard
\begin_inset Formula $D\left(\left\langle M\right\rangle \right)=\begin{cases}
\text{accept} & \text{If M does not accept \left\langle M\right\rangle }\\
\text{reject} & \text{If M accepts \left\langle M\right\rangle  }
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
Now, we run D on itself, to get
\end_layout

\begin_layout Standard
\begin_inset Formula $D\left(\left\langle D\right\rangle \right)=\begin{cases}
\text{accept} & \text{If D rejects \left\langle D\right\rangle }\\
\text{reject} & \text{If D accepts \left\langle D\right\rangle  }
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
Therefore, we have derived a turing machine where running 
\begin_inset Formula $\left\langle D\right\rangle $
\end_inset

 on D accepts if D rejects 
\begin_inset Formula $\left\langle D\right\rangle $
\end_inset

, and D rejects if D accepts 
\begin_inset Formula $\left\langle D\right\rangle $
\end_inset

.
 This is contradictory behavior, therefore, no such TM D can exist, therefore,
 
\begin_inset Formula $A_{TM}$
\end_inset

 is NOT decidable.
 
\end_layout

\begin_layout Subsubsection
Final note:
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $A_{TM}$
\end_inset

 is recognisable, and 
\begin_inset Formula $A_{TM}$
\end_inset

 is not decidable, 
\begin_inset Formula $\overline{A_{TM}}$
\end_inset

 must be unrecognisable
\end_layout

\begin_layout Subsection
Another undecidable language: HALT
\end_layout

\begin_layout Standard
HALT=
\begin_inset Formula $\left\{ \left\langle M,w\right\rangle \vert\text{ M is a TM and M halts on input w}\right\} $
\end_inset


\end_layout

\begin_layout Subsubsection
Showing HALT is undecidable
\end_layout

\begin_layout Standard
Assume for purposes of contradiction that TM R decides HALT, then we can
 construct a TM S to decide 
\begin_inset Formula $A_{TM}$
\end_inset

:
\end_layout

\begin_layout Quote
S= 
\begin_inset Quotes eld
\end_inset

On input 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

, an encoding of a TM M and a string w:
\end_layout

\begin_deeper
\begin_layout Quote
1.
 Run TM R on input 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset


\end_layout

\begin_layout Quote
2.
 If R rejects, reject
\end_layout

\begin_layout Quote
3.
 If R accepts, simulate M on w until it halts.
\end_layout

\begin_layout Quote
4.
 If M has accepted, accept; if M has rejected, reject.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Now, the proof that 
\begin_inset Formula $\mathcal{L}\left(S\right)=A_{TM}$
\end_inset

.
 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle M,w\right\rangle \in A_{TM}$
\end_inset

, then M accepts w.
 Therefore, R will accept 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

, and simulating M on w until halt will result in M accepting w, therefore,
 
\begin_inset Formula $\left\langle M,w\right\rangle \in\mathcal{L}\left(S\right)$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle M,w\right\rangle \not\in A_{TM}$
\end_inset

, then M rejects or loops on w
\end_layout

\begin_layout Standard
1.
 If M rejects w, then R will accept 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

, and simulating M on w until halt will result in a rejection, so S rejects,
 implying 
\begin_inset Formula $\left\langle M,w\right\rangle \not\in S$
\end_inset


\end_layout

\begin_layout Standard
2.
 If M loops on w, R will reject 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

, resulting in S rejecting 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

, implying 
\begin_inset Formula $\left\langle M,w\right\rangle \not\in S$
\end_inset


\end_layout

\begin_layout Standard
Therefore, 
\begin_inset Formula $\mathcal{L}\left(S\right)=A_{TM}$
\end_inset

, implying S is a decider for 
\begin_inset Formula $A_{TM}$
\end_inset

.
 This implies that 
\begin_inset Formula $A_{TM}$
\end_inset

 is decidable.
 Therefore, by contraction, HALT is undecidable
\end_layout

\begin_layout Subsubsection
Showing HALT is recognisable
\end_layout

\begin_layout Standard
Here is a recogniser for HALT:
\end_layout

\begin_layout Quote
D= 
\begin_inset Quotes eld
\end_inset

On input 
\begin_inset Formula $\left\langle M,w\right\rangle $
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Quote
1.
 Run M on w
\end_layout

\begin_layout Quote
2.
 accept
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Proof that D is a recogniser for HALT.
 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle M,w\right\rangle \in$
\end_inset

 HALT, then M halts on w, which implies that step 2 of D is reached, and
 D accepts, therefore, 
\begin_inset Formula $\left\langle M,w\right\rangle \in\mathcal{L}\left(D\right)$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle M,w\right\rangle \not\in$
\end_inset

 HALT, then M loops on w, which implies that step 2 is never reached, so
 D does not accept, therefore, 
\begin_inset Formula $\left\langle M,w\right\rangle \not\in\mathcal{L}\left(D\right)$
\end_inset


\end_layout

\begin_layout Standard
Therefore, 
\begin_inset Formula $\mathcal{L}\left(D\right)=$
\end_inset

HALT
\end_layout

\begin_layout Subsubsection
Conclusion
\end_layout

\begin_layout Standard
HALT is recognisable and co-unrecognisable.
\end_layout

\begin_layout Subsection
The definition of a mapping reduction,
\end_layout

\begin_layout Standard
Language A is mapping reducable to language B if there is some turing machine
 F st 
\begin_inset Formula $w\in A\iff F\left(w\right)\in B$
\end_inset

.
 This is written as 
\begin_inset Formula $A\leq_{m}B$
\end_inset

.
 Be very careful with this notation, it is extremely confusing.
\end_layout

\begin_layout Standard
Note: This definition relies on the concept of using turing machines as
 functions.
 
\begin_inset Formula $F(w)$
\end_inset

 is defined as 
\begin_inset Quotes eld
\end_inset

Whatever is left on the tape after F halts on w
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Note 2: F must not loop on any inputs
\end_layout

\begin_layout Subsection
How can mapping reductions be used to prove that languages are not decidable
 or recognisable?
\end_layout

\begin_layout Subsubsection
Proof that 
\begin_inset Quotes eld
\end_inset

If 
\begin_inset Formula $A\leq_{m}B$
\end_inset

 and B is turing-recongisable, then A is turing-recognisable
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Let M recognise B, here is a recogniser for A:
\end_layout

\begin_layout Quote
N= 
\begin_inset Quotes eld
\end_inset

On input w:
\end_layout

\begin_deeper
\begin_layout Quote
1.
 Compute 
\begin_inset Formula $w^{\prime}=F\left(w\right)$
\end_inset


\end_layout

\begin_layout Quote
2.
 Run M on input 
\begin_inset Formula $w^{\prime}$
\end_inset


\end_layout

\begin_layout Quote
3.
 If M accepts, accept, else reject
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Here is a proof that N recognises A:
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $w\in A$
\end_inset

, then 
\begin_inset Formula $w^{\prime}=F(w)\in B$
\end_inset

 because of the mapping reduction.
 Therefore, M accepts 
\begin_inset Formula $w^{\prime}$
\end_inset

, and N accepts, therefore 
\begin_inset Formula $w\in\mathcal{L}\left(N\right)$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $w\not\in A$
\end_inset

, then 
\begin_inset Formula $w^{\prime}=F(w)\not\in B$
\end_inset

 because of the mapping reduction.
 Therefore, M does not accept 
\begin_inset Formula $w^{\prime}$
\end_inset

, and N does not accept, therefore 
\begin_inset Formula $w\not\in\mathcal{L}\left(N\right)$
\end_inset


\end_layout

\begin_layout Standard
Therefore, 
\begin_inset Formula $\mathcal{L}\left(N\right)=A$
\end_inset

, showing that A is recognisable.
 
\end_layout

\begin_layout Subsubsection
Corollary: If 
\begin_inset Formula $A\leq_{m}B$
\end_inset

 and A is not Turing-recognisable, then B is not Turing-recognisable
\end_layout

\begin_layout Standard
We know that if 
\begin_inset Formula $A\leq_{m}B$
\end_inset

 and B is turing-recognisable, then A is turing-recognisable.
 Taking the contraposition, we get
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

If A is not turing-recognisable, then 
\begin_inset Formula $A\not\leq_{m}B$
\end_inset

 or B is not turing-recognisable
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
However, we know 
\begin_inset Formula $A\leq_{m}B$
\end_inset

 and that A is not turing-recognisable by assumption, therefore, we know
 that B must not be turing-recognisable using the contraposition'd statement.
\end_layout

\begin_layout Standard
Therefore, If 
\begin_inset Formula $A\leq_{m}B$
\end_inset

 and A is not turing-recognisable, then B is not turing-recognisable
\end_layout

\begin_layout Subsubsection
How to use mapping reductions to prove that languages are not decidable
 or recognisable:
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Nick Cheng additional notes"
target "https://www.utsc.utoronto.ca/~nick/cscC63/additional-notes/mapping.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Part
Classifying DECIDABLE langauges as P or NP
\end_layout

\begin_layout Standard
The previous part focused on which lanagues (i.e.
 algorithms) are can actually be run on computers.
 This part focuses on what time those algorithms will take to compute.
 Note: henceforth, we will 
\series bold
ONLY DEAL WITH DECIDABLE LANGUAGES.
 UNDECIDABLE LANGUAGES HAVE NO TIME COMPLEXITY AS P AND NP ARE SUBSETS OF
 THE DECIDABLE LANGUAGES.
 
\end_layout

\begin_layout Section
What is P?
\end_layout

\begin_layout Standard
P is the class of languages which have polynomial time solvers
\end_layout

\begin_layout Subsection
What's a polytime solver?
\end_layout

\begin_layout Standard
A polytime solver for language L is a decider S, which runs in 
\begin_inset Formula $\mathcal{O}\left(n^{k}\right)$
\end_inset

 time for some constant k, where 
\begin_inset Formula $n=\left|w\right|$
\end_inset

, forall 
\begin_inset Formula $w\in L$
\end_inset

.
\end_layout

\begin_layout Subsection
In english pls?
\end_layout

\begin_layout Standard
If L is in P, then there is some decider for L which runs in polynomial
 time.
\end_layout

\begin_layout Section
What is NP?
\end_layout

\begin_layout Standard
NP is a class of languages that have polynomial time verifiers
\end_layout

\begin_layout Subsection
Verifiers
\end_layout

\begin_layout Standard
A verifier for a language A is an algorithm V where
\end_layout

\begin_layout Standard
\begin_inset Formula $A=\left\{ w|\text{ V accepts \left\langle w,c\right\rangle  for some string c }\right\} $
\end_inset


\end_layout

\begin_layout Standard
The time it takes to run a verifier is measured in terms of the length of
 w.
 In this system, c is the certificate
\end_layout

\begin_layout Subsection
The Big Cheng 5: Proving a problem in NP the right way!
\end_layout

\begin_layout Enumerate
Show that Q is a decision problem.
 This is usually quite obvious from the way Q’s question is asked, so merely
 stating that Q is a decision problem will often be sufficient.
 
\end_layout

\begin_layout Enumerate
Describe what a certificate would be for a Yes instance of Q.
 Most of the time this is also quite obvious from the way Q’s question is
 asked.
 If the question asks, “is there a blah?”, (i.e., it essentially asks for
 the existence of something), then usually the certificate is simply the
 blah (the thing about whose existence is asked by the question).
 
\end_layout

\begin_layout Enumerate
Explain why the certificate is polysize with respect to the input size.
 Frequently the certificate is no larger than the input.
 In such cases the certificate size is at most linear with respect to the
 input size.
 
\end_layout

\begin_layout Enumerate
Describe what a verification algorthm would do.
 The certificate is commonly something that satisfies some set of criteria.
 So the algorithm needs to check (or verify) that these criteria are satisfied.
 
\end_layout

\begin_layout Enumerate
Explain why the verification algorithm runs in polytime.
 Typically we would only need to give running times for the checks that
 the algorithm performs
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
This is the official, immutable way to show that a problem is in NP, this
 is the only way to do it, and there are no other ways.
 We will henceforth follow them religiously.
\end_layout

\begin_layout Section
What is NP closed under? (Assignment 3 Q2 solution)
\end_layout

\begin_layout Subsection
Prove that NP is closed under union, intersection, concaterntaion, and Kleene
 star
\end_layout

\begin_layout Subsubsection
Let 
\begin_inset Formula $A,B\in\text{NP}$
\end_inset

, show 
\begin_inset Formula $A\cup B\in\text{NP}$
\end_inset


\end_layout

\begin_layout Standard
If A,B are in NP, then A and B have polynomial time verifiers verifyA and
 verifyB.
 Let L=
\begin_inset Formula $A\cup B$
\end_inset

.
 Now, we wish to argue that 
\begin_inset Formula $L\in\text{NP}$
\end_inset


\end_layout

\begin_layout Enumerate
Since A and B are decision questions, asking if an input is in L must also
 be a decision question
\end_layout

\begin_layout Enumerate
A certificate would be 
\begin_inset Formula $\left\langle c_{1},c_{2}\right\rangle $
\end_inset

 where 
\begin_inset Formula $c_{1}$
\end_inset

 is a certificate for verifyA, and 
\begin_inset Formula $c_{2}$
\end_inset

 is a certificate for verifyB
\end_layout

\begin_layout Enumerate
The certificate would be polysize with respect to input size of L since
 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 are polysize with respect to the inputs to A and B.
 
\end_layout

\begin_layout Enumerate
A verification algorithm would pass the input to verifyA and verifyB with
 the appropriate certificates.
 If either verifyA or verifyB returns true, then return true, else false
\end_layout

\begin_layout Enumerate
Our algorithm is polytime since it only runs two polytime algorithms, verifyA
 and verifyB
\end_layout

\begin_layout Subsubsection
WTS: Let 
\begin_inset Formula $A,B\in\text{NP}$
\end_inset

, show 
\begin_inset Formula $A\cap B\in\text{NP}$
\end_inset


\end_layout

\begin_layout Standard
If A,B are in NP, then A and B have polynomial time verifiers verifyA and
 verifyB.
 Let L=
\begin_inset Formula $A\cap B$
\end_inset

.
 Now, we wish to argue that 
\begin_inset Formula $L\in\text{NP}$
\end_inset


\end_layout

\begin_layout Enumerate
Since A and B are decision questions, asking if an input is in L must also
 be a decision question
\end_layout

\begin_layout Enumerate
A certificate would be 
\begin_inset Formula $\left\langle c_{1},c_{2}\right\rangle $
\end_inset

 where 
\begin_inset Formula $c_{1}$
\end_inset

 is a certificate for verifyA, and 
\begin_inset Formula $c_{2}$
\end_inset

 is a certificate for verifyB
\end_layout

\begin_layout Enumerate
The certificate would be polysize with respect to input size of L since
 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 are polysize with respect to the inputs to A and B.
 
\end_layout

\begin_layout Enumerate
A verification algorithm would pass the input to verifyA and verifyB with
 the appropriate certificates.
 If verifyA and verifyB returns true, then return true, else false
\end_layout

\begin_layout Enumerate
Our algorithm is polytime since it only runs two polytime algorithms, verifyA
 and verifyB
\end_layout

\begin_layout Subsubsection
WTS: Let 
\begin_inset Formula $A,B\in\text{NP}$
\end_inset

, show 
\begin_inset Formula $AB\in\text{NP}$
\end_inset


\end_layout

\begin_layout Standard
If A,B are in NP, then A and B have polynomial time verifiers verifyA and
 verifyB.
 Let L=
\begin_inset Formula $AB$
\end_inset

.
 Now, we wish to argue that 
\begin_inset Formula $L\in\text{NP}$
\end_inset


\end_layout

\begin_layout Enumerate
Since A and B are decision questions, asking if an input is in L must also
 be a decision question
\end_layout

\begin_layout Enumerate
A certificate would be 
\begin_inset Formula $\left\langle c_{1},c_{2}\right\rangle $
\end_inset

 where 
\begin_inset Formula $c_{1}$
\end_inset

 is a certificate for verifyA, and 
\begin_inset Formula $c_{2}$
\end_inset

 is a certificate for verifyB
\end_layout

\begin_layout Enumerate
The certificate would be polysize with respect to input size of L since
 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 are polysize with respect to the inputs to A and B.
 
\end_layout

\begin_layout Enumerate
VerifyL
\end_layout

\begin_layout Enumerate
If n=
\begin_inset Formula $\left|w\right|$
\end_inset

, then, worst case, verifyA will be run n times, and verifyB will be run
 n times.
 This is n times some polynomial, which itself, is a polynomial.
 Therefore, this algorithm runs in polytime.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Verse
VerifyL
\begin_inset Formula $\left\langle w,\left\langle c_{1},c_{2}\right\rangle \right\rangle :$
\end_inset


\end_layout

\begin_deeper
\begin_layout Verse
for 
\begin_inset Formula $i=0\to\left|w\right|:$
\end_inset


\end_layout

\begin_deeper
\begin_layout Verse
if verifyA
\begin_inset Formula $(w[0..i],c_{1})$
\end_inset

 and verifyB
\begin_inset Formula $\left(w[i..],c_{2}\right)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Verse
return true;
\end_layout

\end_deeper
\end_deeper
\begin_layout Verse
return false;
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
WTS: Let 
\begin_inset Formula $A\in\text{NP}$
\end_inset

, show 
\begin_inset Formula $A^{\star}\in\text{NP}$
\end_inset


\end_layout

\begin_layout Standard
If A is in NP, then A has a polynomial time verifier verifyA.
 Let L=
\begin_inset Formula $A^{\star}$
\end_inset

.
 Now, we wish to argue that 
\begin_inset Formula $L\in\text{NP}$
\end_inset


\end_layout

\begin_layout Enumerate
This is a decision problem
\end_layout

\begin_layout Enumerate
A certificate 
\begin_inset Formula $\left\langle c\right\rangle $
\end_inset

 would be the same as a certificate to A
\end_layout

\begin_layout Enumerate
The certificate is polysize with respect to input size since its polysize
 with respect to inputs to A, which are less than or equal to inputs to
 L
\end_layout

\begin_layout Enumerate
A verifier would iterate through the input, running verifyA on 
\begin_inset Formula $\left\langle w\left[0..i\right],c\right\rangle $
\end_inset

.
 If verifyA returns true, return true, else false
\end_layout

\begin_layout Enumerate
This is polytime with respect to 
\begin_inset Formula $\left|w\right|=n$
\end_inset

, since the input is of size n, and verifyA, which is polynomial, will get
 run n times, which is polytime
\end_layout

\begin_layout Section
NP-COMPLETENESS
\end_layout

\begin_layout Standard
NP-Complete problems are problems that are both in NP and NP-hard.
 An NP-Hard problem is a problem that is at least as hard as all other NP-hard
 problems.
 Putting these toegether, if one NP-complete problem has a polytime solver,
 they all do.
 But, if one NP-complete problem can be shown to have no polytime solver,
 none of them do
\end_layout

\begin_layout Subsection
The grandfather of NP-Complete problems: SAT
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{SAT}=\left\{ \left\langle \phi\right\rangle \vert\phi\text{ is a satisfiable boolean formula}\right\} $
\end_inset


\end_layout

\begin_layout Standard
A satisfiable boolean formula is a boolean formula such that some assignment
 of variables makes the formula output true.
 Truth assignments are often labeled 
\begin_inset Formula $\tau$
\end_inset

, and assigning the variables in 
\begin_inset Formula $\phi$
\end_inset

 with the assignments in 
\begin_inset Formula $\tau$
\end_inset

 is 
\begin_inset Formula $\tau\left(\phi\right)$
\end_inset


\end_layout

\begin_layout Standard
This proof looks too big to put here
\end_layout

\begin_layout Section
Polytime reductions
\end_layout

\begin_layout Standard
Language A is polytime reducible to language B, 
\begin_inset Formula $A\leq_{p}B$
\end_inset

 if a TOTAL, POLYTIME, and COMPUTABLE function 
\begin_inset Formula $f:\Sigma^{\star}\to\Sigma^{\star}$
\end_inset

 exists with the property that 
\begin_inset Formula $w\in A\iff f(w)\in B$
\end_inset

.
\end_layout

\begin_layout Standard
So to reduce A to B, create a function which maps yes instances of A to
 yes instances of B, and no instances of A to no instances of B, this is
 the contrapositive.
 
\end_layout

\begin_layout Subsection
How do polytime reductions relate to time complexity?
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $A\leq_{p}B$
\end_inset

, or A polytime reduces to B, and B is in P, then, here's a polytime solver
 for A
\end_layout

\begin_layout Quote
solveA
\begin_inset Formula $\left\langle w\right\rangle :$
\end_inset


\end_layout

\begin_deeper
\begin_layout Quote
\begin_inset Formula $w_{b}=f(w)$
\end_inset


\end_layout

\begin_layout Quote
return solveB
\begin_inset Formula $\left(w_{b}\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Since f is a polytime computable total function that maps yes instances
 of A to yes instances of B, and solveB is polytime, if solveB accepts,
 then w must be in A, and if solveB rejects, w must NOT be in A.
 Additionally, since B and f are polytime computable, solveA must be polytime
 computable.
 This is the core of polytime computability
\end_layout

\begin_layout Subsection
Polytime reductions and it's incomprehensible notation
\end_layout

\begin_layout Standard
\begin_inset Formula $\leq_{p}$
\end_inset

 is one of the most confusing and poorly implemented operators I have ever
 seen.
 Typically, symbols notate a relation between two objects.
 The 
\begin_inset Quotes eld
\end_inset

justification
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Formula $\leq_{p}$
\end_inset

 is that if 
\begin_inset Formula $A\leq_{p}B$
\end_inset

, A is 
\begin_inset Quotes eld
\end_inset

Less than or equal to B
\begin_inset Quotes erd
\end_inset

 in terms of hardness.
 This is complete gibberish.
 This is an 
\begin_inset Quotes eld
\end_inset

operator
\begin_inset Quotes erd
\end_inset

 which communicates the thing one can prove using the existence of a relation
 between two objects.
 Imagine if we wrote all notation this way! There would be COMPLETE ANARCHY!!!!
 Not only that, but this convention encourages un-mathematical, un-creative,
 instrumentalist applications of mathematical reasoning.
 This is wholly unfit for a theoretical course.
 This is unlike all other notation, and the person who invented it should
 be candidate #2 for NASA's man-on-the-sun space mission right after Elon
 Musk.
\end_layout

\begin_layout Subsubsection
How to remember this difficult notation
\end_layout

\begin_layout Standard
Rule 1: read right to left: if 
\begin_inset Formula $A\leq_{p}B$
\end_inset

, then a polytime reduction FROM A, TO B exists, I.e.
 inputs in A, go TO, B.
 The english phraseology gets this exactly correct.
 A polytime reduction goes from A to B, and the inputs of A, go TO B.
 
\end_layout

\begin_layout Subsection
Polytime reduction definition of NP-complete
\end_layout

\begin_layout Standard
Using our new approach, we can define NP-completeness to be
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

A language B is NP-complete if it satisfies two conditions:
\end_layout

\begin_layout Standard
1.
 B is in NP
\end_layout

\begin_layout Standard
2.
 if A
\begin_inset Formula $\in$
\end_inset

NP, then 
\begin_inset Formula $A\leq_{p}B$
\end_inset

 for any A in NP
\end_layout

\begin_layout Standard
This works because if B has a polytime solver, then A must have a polytime
 solver.
 This means that B's solvability in polynomial time makes a claim about
 every single NP-complete problem's solvability in polytime, which is the
 point of the NP-complete class
\end_layout

\begin_layout Section
The first reduction: SAT
\begin_inset Formula $\leq_{p}$
\end_inset

3SAT 
\end_layout

\begin_layout Standard
PROVE 3SAT is in NP! 
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{3SAT}=\left\{ \phi\vert\phi\text{ is a 3-cnf formula which is satisfiable}\right\} $
\end_inset


\end_layout

\begin_layout Standard
A 3-cnf formula, or 
\begin_inset Quotes eld
\end_inset

conjunctive normal form formula with 3 variables in each clause
\begin_inset Quotes erd
\end_inset

 is composed of clauses as follows: 
\begin_inset Formula $\left(x\vee y\vee\neg x\right)\wedge\left(z\vee p\vee\neg x\right)\wedge\cdots$
\end_inset

.
 Notably, these formulas have no constants.
 An easy way to remember is that cnf formulas are 
\begin_inset Quotes eld
\end_inset

sad
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\left(^{\odot}\vee^{\odot}\right)$
\end_inset


\end_layout

\begin_layout Standard
WTS: 
\begin_inset Formula $\text{SAT\ensuremath{\leq_{p}}3SAT}$
\end_inset

.
 Showing SAT Polytime reduces to 3SAT will show that if 3SAT is in P, then
 SAT is in P.
 This proves that 3SAT is NP-complete
\end_layout

\begin_layout Standard
The details of this reduction are not super important, since finding an
 algorithm to take any formula composed of literals, ands, or's and nots
 and transforming it into a 3-cnf formula is very boring and not required
 knowledge.
 But an appropriate algorithm would have the following passes:
\end_layout

\begin_layout Standard
1.
 Transform literals into tautologies, 
\begin_inset Formula $\neg x\vee x=1$
\end_inset

, 
\begin_inset Formula $\neg x\wedge x=0$
\end_inset


\end_layout

\begin_layout Standard
2.
 Use de morgan's law to make all nots go directly in front of variables
\end_layout

\begin_layout Standard
3.
 probably many others
\end_layout

\begin_layout Standard
Intuitively, such an algorithm makes sense since we are used to transforming
 logical statements into other equivalent statements, since this was tested
 in a67 and many other courses.
 
\end_layout

\begin_layout Standard
By the principle of arm waiving, we now have a function 
\begin_inset Formula $f\left(\phi\right)\to\phi^{\prime}$
\end_inset

st if 
\begin_inset Formula $\phi$
\end_inset

 is a boolean formula, 
\begin_inset Formula $\phi^{\prime}$
\end_inset

 is a 3-cnf formula.
 and 
\begin_inset Formula $\phi$
\end_inset

 is equivalent to 
\begin_inset Formula $\phi^{\prime}$
\end_inset

.
\end_layout

\begin_layout Standard
Now, for the proof:
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi\in\text{SAT}$
\end_inset

, then 
\begin_inset Formula $\phi^{\prime}$
\end_inset

 is satisfiable, which implies since it is 3-cnf, it is in 3SAT
\end_layout

\begin_layout Standard
(using the contraposition)
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi\not\in\text{SAT}$
\end_inset

, then 
\begin_inset Formula $\phi^{\prime}$
\end_inset

 is not satisfiable, which implies it is not in 3SAT
\end_layout

\begin_layout Standard
QED
\end_layout

\begin_layout Section
The first REAL reduction: 
\begin_inset Formula $\text{3SAT\ensuremath{\leq_{p}}CLIQUE}$
\end_inset

, Showing CLIQUE is NP-complete
\end_layout

\begin_layout Standard
\begin_inset Formula $\text{CLIQUE}=\left\{ \left\langle G,k\right\rangle \vert\text{ G is a graph which contains a clique of size k}\right\} $
\end_inset


\end_layout

\begin_layout Subsection
Proof that CLIQUE
\begin_inset Formula $\in$
\end_inset

NP
\end_layout

\begin_layout Standard
Here's a polytime verifier for CLIQUE:
\end_layout

\begin_layout Standard
Let the certificate C be a set of vertices that form a clique, and let G
 be a graph
\end_layout

\begin_layout Quote
VerifyCLIQUE
\begin_inset Formula $\left\langle \left\langle G,k\right\rangle ,C\right\rangle :$
\end_inset


\end_layout

\begin_deeper
\begin_layout Quote
if 
\begin_inset Formula $\left|C\right|<k$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Quote
return false
\end_layout

\end_deeper
\begin_layout Quote
for each vertex in C:
\end_layout

\begin_deeper
\begin_layout Quote
check that it connects to every other vertex in c
\end_layout

\begin_layout Quote
if it doesn't return false
\end_layout

\end_deeper
\begin_layout Quote
return true
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Worst case, G=C, so at worst, this algorithm runs in 
\begin_inset Formula $n^{2}$
\end_inset

 time.
 This is sufficient justification to show that CLIQUE
\begin_inset Formula $\in$
\end_inset

NP
\end_layout

\begin_layout Subsection
Proof that CLIQUE is NP-complete
\end_layout

\begin_layout Standard
A clique is a set of vertices where each vertex in the clique is connected
 to every other vertex in the clique with an edge.
 
\end_layout

\begin_layout Standard
The way we will go about reducing these is to come up with some equivalent
 structure to clauses, and conjunctions in graphs, often called widgets
 or gadgets.
 Since some have argued that graphs are a 
\begin_inset Quotes eld
\end_inset

universal
\begin_inset Quotes erd
\end_inset

 data structure capable of storing all other data structures, this should
 be easy!
\end_layout

\begin_layout Standard
The steps to make this construction go as follows, Given 3-cnf formula 
\begin_inset Formula $\phi$
\end_inset

, output G and k as follows:
\end_layout

\begin_layout Standard
1.
 For each variable in 
\begin_inset Formula $\phi$
\end_inset

, add a corresponding vertex in 
\begin_inset Formula $G$
\end_inset

named after the variable
\end_layout

\begin_layout Standard
2.
 Connect every vertex to every other vertex in G with an edge
\end_layout

\begin_layout Standard
3.
 Remove all edges between 
\begin_inset Quotes eld
\end_inset

contradictory
\begin_inset Quotes erd
\end_inset

 vertexes like 
\begin_inset Formula $\neg x$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Standard
4.
 Remove all edges between vertexes that appear in the same clause (so if
 
\begin_inset Formula $\left(c_{1}\vee c_{2}\vee c_{3}\right)$
\end_inset

 appears in 
\begin_inset Formula $\phi$
\end_inset

, no edge should exist from 
\begin_inset Formula $c_{1}$
\end_inset

to 
\begin_inset Formula $c_{2}$
\end_inset

 to 
\begin_inset Formula $c_{3}$
\end_inset

)
\end_layout

\begin_layout Standard
5.
 set k to be the number of clauses in 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\begin_layout Standard
Now, to argue that 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT\ensuremath{\iff\left\langle G,k\right\rangle \in\text{CLIQUE}}}$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT}$
\end_inset

, then a satisfiable truth assignment 
\begin_inset Formula $\tau$
\end_inset

 exists such that every clause in 
\begin_inset Formula $\phi$
\end_inset

 returns true.
 This means at least one variable in each triplet evaluates to true.
 If one puts these three variables (henceforth vertices) into a set, these
 vertices will form a k-clique.
 
\end_layout

\begin_layout Standard
Now, for the reverse direction, suppose that G contains a k-clique: 
\end_layout

\begin_layout Standard
We know the elements of this clique must all appear in distinct clauses
 since there are no edges to vertices of the same clause.
 Similarly, we know none of these vertices have edges to contradictory labels
 by the given construction above.
 Now, create a truth assignment 
\begin_inset Formula $\tau$
\end_inset

 with the labels from the vertices inside the k-clique.
 Therefore, this truth assignment must satisfy 
\begin_inset Formula $\phi$
\end_inset

.
 Therefore, if 
\begin_inset Formula $\left\langle G,k\right\rangle \in\text{CLIQUE}$
\end_inset

, then 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT}$
\end_inset


\end_layout

\begin_layout Subsection
What is this?
\end_layout

\begin_layout Standard
What are the gadgets?
\end_layout

\begin_layout Standard
The core idea is that a clique must contain k vertices who's variables can
 ALL BE TRUE at the same time, AND are of different clauses.
 This is a corollary of satisfiability.
 This is why the two restrictions on edges exist.
 In short, the reasoning is that 
\begin_inset Quotes eld
\end_inset

If k variables can be true at the same time (SAT), then an edge exists between
 all of them
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

if k vertices form a clique (CLIQUE), then they can all be true at the same
 time, and are of different clauses
\end_layout

\begin_layout Subsection
Time Complexity Analysis
\end_layout

\begin_layout Standard
I argue that our mapping reduction is polytime because 
\end_layout

\begin_layout Enumerate
It iterates over 
\begin_inset Formula $\phi$
\end_inset

 once to create G's adjacency list: 
\begin_inset Formula $\mathcal{O}\left(n\right)$
\end_inset


\end_layout

\begin_layout Enumerate
It iterates over G's adjacency list once to connect all edges: 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
It iterates twice more to ensure a proper construction: 
\begin_inset Formula $\mathcal{O}\left(2n^{2}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Therefore, this is a polytime construction
\end_layout

\begin_layout Subsection
The big result?
\end_layout

\begin_layout Standard
CLIQUE is NP-complete
\end_layout

\begin_layout Section
Vertex Cover is NP Complete
\end_layout

\begin_layout Standard
VERTEX-COVER=
\begin_inset Formula $\left\{ \left\langle G,k\right\rangle \text{ G is an undirected graph which has a k-node vertex cover}\right\} $
\end_inset


\end_layout

\begin_layout Standard
A vertex cover VC is a set of vertices such that all edges either start
 or end at a node in VC
\end_layout

\begin_layout Subsection
Proof that VERTEX-COVER
\begin_inset Formula $\in$
\end_inset

NP
\end_layout

\begin_layout Standard
Here's a polynomial time verifier for VERTEX-COVER, where C is a set of
 nodes which are in the vertex cover
\end_layout

\begin_layout Quote
VerifyVERTEX-COVER
\begin_inset Formula $\left\langle \left\langle G,k\right\rangle ,C\right\rangle :$
\end_inset


\end_layout

\begin_deeper
\begin_layout Quote
if 
\begin_inset Formula $\left|C\right|<k$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Quote
return false
\end_layout

\end_deeper
\begin_layout Quote
For each vertex in C:
\end_layout

\begin_deeper
\begin_layout Quote
mark each of its adjacent edges as covered
\end_layout

\end_deeper
\begin_layout Quote
for each edge in G:
\end_layout

\begin_deeper
\begin_layout Quote
if the edge is not marked as covered:
\end_layout

\begin_deeper
\begin_layout Quote
return false
\end_layout

\end_deeper
\end_deeper
\begin_layout Quote
return true
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
This verifier clearly runs in polynomial time since it goes through every
 edge of G once, which serves a maximum complexity of 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

, where n is the number of vertices, and 
\begin_inset Formula $n^{2}$
\end_inset

 is the number of edges in a fully connected graph.
\end_layout

\begin_layout Subsection
Proof that VERTEX-COVER is NP-Complete
\end_layout

\begin_layout Standard
While it might seem reasonable to reduce from 
\begin_inset Formula $\text{CLIQUE}\leq_{p}\text{VERTEX-COVER}$
\end_inset

, we are instead going to choose 3SAT
\end_layout

\begin_layout Standard
WTS: 
\begin_inset Formula $\text{3SAT}\leq_{p}\text{VERTEX-COVER}$
\end_inset


\end_layout

\begin_layout Standard
So, our reduction takes inputs in 3SAT, and transforms them into inputs
 into VERTEX-COVER, namely a graph G, and a size k.
 Our input is a 3-cnf formula 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\begin_layout Standard
To make this reduction, we will 
\end_layout

\begin_layout Standard
1.
 Take every variable in 
\begin_inset Formula $\phi$
\end_inset

, and add a vertex in G.
 
\end_layout

\begin_layout Standard
2.
 If 
\begin_inset Formula $x_{i}$
\end_inset

 and 
\begin_inset Formula $\bar{x}_{i}$
\end_inset

appear in 
\begin_inset Formula $G$
\end_inset

, add an edge between 
\begin_inset Formula $x_{i}$
\end_inset

 and 
\begin_inset Formula $\bar{x}_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
3.
 If 3 variables occur in a clause of 
\begin_inset Formula $\phi$
\end_inset

, add a new copy of each variable into G, and add an edge between each new
 vertice to every other vertice (GRAPH NEEDED)
\end_layout

\begin_layout Standard
4.
 Connect all 
\begin_inset Formula $x_{i}$
\end_inset

's to other 
\begin_inset Formula $x_{i}$
\end_inset

's and all 
\begin_inset Formula $\bar{x}_{i}$
\end_inset

to every other 
\begin_inset Formula $\bar{x}_{i}$
\end_inset

 
\end_layout

\begin_layout Standard
5.
 set k to be the number of variables in 
\begin_inset Formula $\phi$
\end_inset

 + 2 times the number of clauses in 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\begin_layout Standard
Now, for the justification: 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT}$
\end_inset

, then, select a satisfiable assignment 
\begin_inset Formula $\tau$
\end_inset

, and put all the variable widgets that are assigned true in 
\begin_inset Formula $\tau$
\end_inset

 into our vertex cover.
 Now, take 1 variable that was assigned true from each clause, and put the
 other two variables in its clause into the vertex cover.
 Since our vertex cover has 1 variable per variable widget in the VC, and
 2 clause widget variables per clause in the VC, it must have k vertices
 in the vertex-cover.
 Therefore, a vertex cover of size k exists.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\left\langle G,k\right\rangle \in\text{VERTEX-COVER}$
\end_inset

, then our Vertex Cover VC, must select 1 and only 1 variable per variable
 widget, since if it selected 2, it would have to skimp out on including
 clause variable widgets, which wouldn't form a full vertex cover.
 In addition, the vertex cover must select 2 nodes from each clause, where
 the unselected node is set to true, since if it didn't it would miss the
 edge from a node which was set to false to the variable widget.
 This forms a VC of size k, and the selected variables in the vertex clause
 must form satisfiable truth assignment since one unselected-but-true edge
 must exist in each clause.
 
\end_layout

\begin_layout Section
HAMPATH is NP-Complete
\end_layout

\begin_layout Standard
A hamiltonian path is a path that visits each vertex of a graph exactly
 once.
 A hamiltonian path from s to t consists of a hamiltonian path with its
 head at s and tail at t.
 (heads and tails since these are directed graphs)
\end_layout

\begin_layout Standard
Formally: 
\begin_inset Formula $\text{HAMPATH}=\left\{ \left\langle G,s,t\right\rangle \vert\text{ G contains a hamiltonian path from s to t}\right\} $
\end_inset


\end_layout

\begin_layout Subsection
HAMPATH
\begin_inset Formula $\in$
\end_inset

NP
\end_layout

\begin_layout Standard
Here is a polytime verifier for HAMPATH.
 Let C, the certificate, be a hamiltonian path (a set of vertexes and edges)
 from s to t.
 
\end_layout

\begin_layout Quote
VerifyHAMPATH
\begin_inset Formula $\left\langle \left\langle G,s,t\right\rangle ,C\right\rangle :$
\end_inset


\end_layout

\begin_deeper
\begin_layout Quote
Trace along the path C: and mark edges G which were visited.
 If an edge that was previously visited is visited again, reject
\end_layout

\begin_layout Quote
check if every vertex in G, if all were visited, accept
\end_layout

\begin_layout Quote
else reject (or loop?)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
This verifier goes through the path C, which is 
\begin_inset Formula $\mathcal{O}\left(n\right)$
\end_inset

.
 Then, checking every vertex is visited takes 
\begin_inset Formula $\mathcal{O}\left(n\right)$
\end_inset

.
 Therefore, this verifier is polynomial time and takes 
\begin_inset Formula $\mathcal{O}\left(n\right)$
\end_inset

.
 
\end_layout

\begin_layout Subsection
HAMPATH is NP-Complete
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
preview true
filename "graphics/hampath.tex"

\end_inset


\end_layout

\begin_layout Section
UHAMPATH is NP-Complete
\end_layout

\begin_layout Standard
A verifier for UHAMPATH is the same as a verifier for HAMPATH
\end_layout

\begin_layout Subsection
UHAMPATH is NP-Hard
\end_layout

\begin_layout Standard
UHAMPATH=
\begin_inset Formula $\left\{ \left\langle G,s,t\right\rangle \vert\text{ G is an undirected graph which contains a hamiltonian path from s to t}\right\} $
\end_inset


\end_layout

\begin_layout Standard
We are going to reduce from HAMPATH
\begin_inset Formula $\leq_{p}$
\end_inset

UHAMPATH
\end_layout

\begin_layout Standard
The construction goes as follows: Given a 
\begin_inset Formula $\left\langle G,s,t\right\rangle $
\end_inset

, an input to HAMPATH, we must construct a 
\begin_inset Formula $\left\langle G^{\prime},s^{\prime},t^{\prime}\right\rangle $
\end_inset

 which is an input to UHAMPATH.
\end_layout

\begin_layout Standard
1.
 For each vertex (except s and t) in G, add 
\begin_inset Formula $v^{i},v^{m},v^{o}$
\end_inset

 to 
\begin_inset Formula $G^{\prime}$
\end_inset

 where i stands for in, m stands for mid, and o stands for out.
 
\end_layout

\begin_layout Standard
2.
 set 
\begin_inset Formula $s^{\prime}$
\end_inset

to 
\begin_inset Formula $s^{o}$
\end_inset

, and 
\begin_inset Formula $t^{\prime}$
\end_inset

 to 
\begin_inset Formula $t^{i}$
\end_inset

.
 
\end_layout

\begin_layout Standard
3.
 Connect 
\begin_inset Formula $v^{m}$
\end_inset

 with 
\begin_inset Formula $v^{i}$
\end_inset

 and 
\begin_inset Formula $v^{o}$
\end_inset


\end_layout

\begin_layout Standard
4.
 If 
\begin_inset Formula $\left(u,v\right)\in E\left(G\right)$
\end_inset

, then connect 
\begin_inset Formula $u^{o}$
\end_inset

 to 
\begin_inset Formula $v^{i}$
\end_inset

.
 
\end_layout

\begin_layout Subsection
The forward direction
\end_layout

\begin_layout Standard
Assume that G contains a hamiltonian path from s to t.
 By the given construction above, each edge 
\begin_inset Formula $\left(u,v\right)\in G$
\end_inset

 has a corresponding path 
\begin_inset Formula $u^{o}\to v^{i}\to v^{m}\to v^{o}\in G^{\prime}$
\end_inset

.
 This implies a UHAMPATH exists from s to t in 
\begin_inset Formula $G^{\prime}$
\end_inset

.
 
\end_layout

\begin_layout Subsection
The reverse direction
\end_layout

\begin_layout Standard
IDEK.
\end_layout

\begin_layout Section
SUBSET-SUM is NP-Complete
\end_layout

\begin_layout Subsection
Proof that SUBSET-SUM
\begin_inset Formula $\in$
\end_inset

 NP
\end_layout

\begin_layout Subsection
Proof that SUBSET-SUM is NP-Hard
\end_layout

\begin_layout Standard
WTS: 
\begin_inset Formula $\text{3SAT\ensuremath{\leq_{p}}SUBSET-SUM}$
\end_inset


\end_layout

\begin_layout Subsubsection
The construction
\end_layout

\begin_layout Standard
Given a 3-cnf 
\begin_inset Formula $\phi$
\end_inset

, an input to 3SAT, with l variables, and i clauses.
 Make a table as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{c|cccc|cccc}
 & x_{1} & x_{2} & \cdots & x_{l} & c_{1} & c_{2} & \cdots & c_{i}\\
t_{1} & 1 & 0 & 0 & 0\\
f_{1} & 1 & 0 & 0 & 0\\
t_{2} & 0 & 1 & 0 & 0\\
f_{2} & 0 & 1 & 0 & 0\\
\vdots & 0 & 0 & \vdots & 0\\
\vdots & 0 & 0 & \vdots & 0\\
t_{l} &  &  &  & 1\\
f_{l} &  &  &  & 1\\
\hline t & 1 & 1 & \cdots & 1\\
 &  &  &  & \\
 &  &  &  & \\
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
We are going to make the rows our subset, and the row t will be our sum.
 If row 
\begin_inset Formula $t_{1}$
\end_inset

 is selected then make variable 
\begin_inset Formula $x_{1}$
\end_inset

 true, and if row 
\begin_inset Formula $f_{1}$
\end_inset

 is selected, make variable 
\begin_inset Formula $x_{1}$
\end_inset

 false.
 Since t contains a 1 in each column with a variable, this means that every
 variable can only be assigned true or false.
 
\end_layout

\begin_layout Standard
Next, modify the table.
 If 
\begin_inset Formula $t_{j}$
\end_inset

 is selected, mark each clause in the row 
\begin_inset Formula $t_{j}$
\end_inset

 1 if 
\begin_inset Formula $x_{j}$
\end_inset

 appears in the clause like so:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{c|cccc|cccc}
 & x_{1} & x_{2} & \cdots & x_{l} & c_{1} & c_{2} & \cdots & c_{i}\\
t_{1} & 1 & 0 & 0 & 0 & 1 & 0 & \cdots & 0\\
f_{1} & 1 & 0 & 0 & 0 & 0 & 1 & \cdots & 1\\
t_{2} & 0 & 1 & 0 & 0 &  & \vdots\\
f_{2} & 0 & 1 & 0 & 0\\
\vdots & 0 & 0 & \vdots & 0\\
\vdots & 0 & 0 & \vdots & 0\\
t_{l} &  &  &  & 1\\
f_{l} &  &  &  & 1\\
\hline t & 1 & 1 & \cdots & 1\\
 &  &  &  & \\
 &  &  &  & \\
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
Now, we have to ensure that at least 1 variable in each clause is marked
 as true.
 The problem is that one clause, two clauses, and three clauses could be
 true.
 The way we control for this is adding two extra rows per clause, which
 both contain a 1, like so: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{array}{c|cccc|cccc}
 & x_{1} & x_{2} & \cdots & x_{l} & c_{1} & c_{2} & \cdots & c_{i}\\
t_{1} & 1 & 0 & 0 & 0 & 1 & 0 & \cdots & 0\\
f_{1} & 1 & 0 & 0 & 0 & 0 & 1 & \cdots & 1\\
t_{2} & 0 & 1 & 0 & 0 &  & \vdots\\
f_{2} & 0 & 1 & 0 & 0\\
\vdots & 0 & 0 & \vdots & 0\\
\vdots & 0 & 0 & \vdots & 0\\
t_{l} &  &  &  & 1\\
f_{l} &  &  &  & 1 & 1 & 0 & \cdots & 1\\
\hline h_{1} & 0 & 0 & 0 & 0 & 1\\
g_{1} & 0 & 0 & 0 & 0 & 1\\
h_{2} & 0 & 0 & \vdots & 0 &  & 1\\
g_{2} & 0 & 0 & \cdots & 0 &  & 1\\
h_{3} & 0 & 0 & 0 & 0 &  &  & \cdots\\
g_{3} & 0 & 0 & 0 & 0 &  &  & \cdots\\
h_{4} & 0 & 0 & 0 & 0 &  &  &  & 1\\
g_{4} & 0 & 0 & 0 & 0 &  &  &  & 1\\
\hline t & 1 & 1 & \cdots & 1 & 3 & 3 & 3 & 3\\
 &  &  &  & \\
 &  &  &  & \\
\end{array}$
\end_inset


\end_layout

\begin_layout Standard
Now, let t be the t row, and the subset S be all the other rows of the table.
 
\end_layout

\begin_layout Subsubsection
Given that 
\begin_inset Formula $\phi\in\text{3SAT}$
\end_inset

, show 
\begin_inset Formula $\left\langle S,t\right\rangle \in\text{SUBSET-SUM}$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi$
\end_inset

 is in 3SAT, that means there is a truth assignment 
\begin_inset Formula $\tau$
\end_inset

 which satisfies 
\begin_inset Formula $\phi$
\end_inset

.
 This 
\begin_inset Formula $\phi$
\end_inset

 must also satisfy at least one variable in each clause.
 By the above construction, that implies that there must be some subset
 which sums to t.
\end_layout

\begin_layout Subsubsection
Given that 
\begin_inset Formula $\left\langle S,t\right\rangle \in\text{SUBSET-SUM}$
\end_inset

, show 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT}$
\end_inset


\end_layout

\begin_layout Standard
We know S has some subset which sums to t.
 Using the variable construction, we know this subset must select either
 
\begin_inset Formula $t_{i}$
\end_inset

 or 
\begin_inset Formula $f_{i}$
\end_inset

 for 
\begin_inset Formula $1\leq i\leq l$
\end_inset

, where l is the number of rows (variables) in this section of the construction.
 Let our truth assignment 
\begin_inset Formula $\tau$
\end_inset

 assign true and false accordingly (true if 
\begin_inset Formula $t_{i}$
\end_inset

 is selected, false if 
\begin_inset Formula $f_{i}$
\end_inset

 is selected).
 In the second quadrent of the table, the clause section, if there is a
 subset sum which sums to t, then that subset must contain at least a 1
 for each clause.
 By the above construction, this implies 
\begin_inset Formula $\tau$
\end_inset

 sets each clause to true.
 This implies that 
\begin_inset Formula $\phi$
\end_inset

 is satisfiable, which implies that 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT}$
\end_inset


\end_layout

\begin_layout Subsubsection
Justification that this reduction is polytime.
 
\end_layout

\begin_layout Standard
To constructing the structure (dimensions and layout) of the table, which
 is assumed to be constant time, filling out the variables section takes
 
\begin_inset Formula $\mathcal{O}\left(l\right)$
\end_inset

 time, and filling out the clause section takes 
\begin_inset Formula $3\cdot\mathcal{O}\left(l\right)$
\end_inset

 time, where l is the number of variables.
 If n is the number of variables in 
\begin_inset Formula $\phi$
\end_inset

, this reduction takes 
\begin_inset Formula $\mathcal{O}\left(l\right)$
\end_inset

 time, which is polytime.
 
\end_layout

\begin_layout Section
3-COL is NP-Complete
\end_layout

\begin_layout Standard
3-col: 
\end_layout

\begin_layout Standard
Input: A graph G
\end_layout

\begin_layout Standard
Question: Is there a coloring of G with 3 colors such that no two adjacent
 vertices share the same color.
\end_layout

\begin_layout Subsection
Proving that 3-COL is in NP
\end_layout

\begin_layout Standard
1.
 3-COL asks us if an object exists or not.
 This means its a decision problem
\end_layout

\begin_layout Standard
2.
 A certificate would be a function which maps vertices to colorings.
 
\end_layout

\begin_layout Standard
3.
 For 3-COL, the input size is measured as the number of vertices in G.
 This is linear to a map which takes the vertices of G as input, for obvious
 reasons
\end_layout

\begin_layout Standard
4.
 The verification algorithm would iterate over each vertex, and check that
 none of its neighbors are colored with the same color
\end_layout

\begin_layout Standard
5.
 For a worst-case fully connected graph, this verifier would have to check
 each node and its n neighbors.
 This means it runs in 
\begin_inset Formula $n^{2}$
\end_inset

 time
\end_layout

\begin_layout Subsection
Showing that 3-COL is NP-Hard
\end_layout

\begin_layout Standard
WTS: 3SAT
\begin_inset Formula $\leq_{p}$
\end_inset

3COL
\end_layout

\begin_layout Subsubsection
The construction
\end_layout

\begin_layout Standard
We need three core technologies to complete this reduction: The Variable
 Widget, the Clause Widget, and the Palette, as well as our three colors:
 True, False, and Red.
\end_layout

\begin_layout Standard
First, the palette looks like:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "graphics/palette_widget.tex"

\end_inset


\end_layout

\begin_layout Standard
In order for this graph to be 3-colorable, this palette widget must have
 3 distinct colors on each vertex.
 With out loss of generality, let these vertexes be named True, False, and
 Red, with the assumption that a 3-coloring of this graph will color these
 vertices approprietly.
 
\end_layout

\begin_layout Standard
Next is the variable widget: 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "graphics/variable_widget.tex"

\end_inset


\end_layout

\begin_layout Standard
This widget assures that variables can only be assigned the true color or
 the false color (which will correspond with their truth assignments).
 In addition, these widgets assure that a variable and its complement cannot
 be assigned to the same color.
 
\end_layout

\begin_layout Standard
Finally, and most complicated: The clause widget: 
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "graphics/clause_widget.tex"

\end_inset


\end_layout

\begin_layout Subsubsection
Assume 
\begin_inset Formula $\left\langle \phi\right\rangle \in\text{3SAT}$
\end_inset

, show 
\begin_inset Formula $\left\langle G\right\rangle \in$
\end_inset

3COL
\end_layout

\begin_layout Subsubsection
Assume 
\begin_inset Formula $\left\langle G\right\rangle \in$
\end_inset

3COL, show 
\begin_inset Formula $\left\langle \phi\right\rangle \in$
\end_inset

3SAT
\end_layout

\begin_layout Subsubsection
The reduction is polytime
\end_layout

\begin_layout Section
Assignment question: 2b
\end_layout

\begin_layout Subsection
Prove that DISJOINT-CLIQUE is in NP
\end_layout

\begin_layout Subsection
Show DISJOINT-CLIQUE is NP-Complete
\end_layout

\begin_layout Standard
We will reduce from 
\begin_inset Formula $\text{CLIQUE}\leq_{p}\text{DISJOINT-CLIQUE}$
\end_inset


\end_layout

\begin_layout Standard
To transform an input to CLIQUE 
\begin_inset Formula $\left\langle G,k\right\rangle $
\end_inset

 to an input 
\begin_inset Formula $\left\langle G^{\prime},k^{\prime}\right\rangle $
\end_inset

 to DISJOINT-CLIQUE, do as follows:
\end_layout

\begin_layout Standard
1.
 Put all vertices with k-1 or more edges into a group C
\end_layout

\begin_layout Standard
2.
 Let 
\begin_inset Formula $G^{\prime}=C+C^{\prime}$
\end_inset

where 
\begin_inset Formula $C^{\prime}$
\end_inset

is all of the edges and vertices in C but with an added 
\begin_inset Formula $\prime$
\end_inset

 to the vertex names
\end_layout

\begin_layout Standard
3.
 Let 
\begin_inset Formula $k^{\prime}=k$
\end_inset


\end_layout

\begin_layout Standard
Pf that this reduciton works:
\end_layout

\begin_layout Subsubsection
Assume 
\begin_inset Formula $\left\langle G,k\right\rangle \in\text{CLIQUE}$
\end_inset

,
\end_layout

\begin_layout Standard
If G has a clique of size k, then all edges in the clique must have k-1
 or more edges leading out of it.
 This implies that all these edges are cloned into 
\begin_inset Formula $G^{\prime}$
\end_inset

, which implies that 
\begin_inset Formula $G^{\prime}$
\end_inset

has two cliques of size k (or more).
 This implies that 
\begin_inset Formula $\left\langle G^{\prime},k^{\prime}\right\rangle \in\text{DISJOINT-CLIQUE}$
\end_inset


\end_layout

\begin_layout Subsubsection
Assume 
\begin_inset Formula $\left\langle G^{\prime},k^{\prime}\right\rangle \in\text{DISJOINT-CLIQUE}$
\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $G^{\prime}$
\end_inset

 has at least two cliques of size k, then suppose for purposes of contradiction
 that 
\begin_inset Formula $G$
\end_inset

 has no clique of size k.
 If G has no clique of size k, then no subset of 
\begin_inset Formula $C^{\prime}$
\end_inset

 must form a clique of size k.
 This implies that none of the components of C form a clique of size k.
 This implies that 
\begin_inset Formula $G^{\prime}$
\end_inset

, which equals 
\begin_inset Formula $C+C^{\prime}$
\end_inset

, has no cliques of size k, which is a contradiction to the assumption that
 
\begin_inset Formula $G^{\prime}$
\end_inset

 has at least two cliques of size k.
 Therefore, if 
\begin_inset Formula $\left\langle G^{\prime},k^{\prime}\right\rangle \in\text{DISJOINT-CLIQUE\ensuremath{\implies\left\langle G,k\right\rangle \in\text{CLIQUE}}}$
\end_inset


\end_layout

\begin_layout Subsubsection
This reduction is polytime
\end_layout

\begin_layout Standard
Finding all the vertices with 
\begin_inset Formula $k-1$
\end_inset

 or more edges takes 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

 time, so this reduction is polytime
\end_layout

\begin_layout Subsection
Find a non-decision version of DISJOINT-CLIQUE
\end_layout

\begin_layout Standard
MAX-DISJOINT-CLIQUE
\end_layout

\begin_layout Standard
Input: A graph G
\end_layout

\begin_layout Standard
Output: A set of vertices 
\begin_inset Formula $V_{1}$
\end_inset

, 
\begin_inset Formula $V_{2}$
\end_inset

 such that 
\begin_inset Formula $V_{1}$
\end_inset

 and 
\begin_inset Formula $V_{2}$
\end_inset

 are disjoint cliques, and there are no two disjoint cliques of greater
 size in G
\end_layout

\begin_layout Standard
I did not want to prove this
\end_layout

\begin_layout Subsection
Find a non-decision version
\end_layout

\begin_layout Section
COL is NP-complete
\end_layout

\begin_layout Standard
COL=
\begin_inset Formula $\left\{ \left\langle G,k\right\rangle \vert\text{ the nodes in G can be colored with k colors st no two nodes joined by an edge have the same color}\right\} $
\end_inset


\end_layout

\begin_layout Subsection
Proof that COL
\begin_inset Formula $\in\text{NP}$
\end_inset


\end_layout

\begin_layout Enumerate
Col is a decision problem since its a language
\end_layout

\begin_layout Enumerate
A certificate to a verifier for COL would be a k-coloring of each node in
 G
\end_layout

\begin_layout Enumerate
The certificate would be polysize with respect to 
\begin_inset Formula $\left\langle G,k\right\rangle $
\end_inset

 since it would have one entry per vertex in G, which implies linearity
\end_layout

\begin_layout Enumerate
A verifier would check that the coloring was valid by iterating through
 every vertex and checking that its neighbors are not the same color
\end_layout

\begin_layout Enumerate
The verifier would be polytime because, worst case, for a fully connected
 graph, the verifier would have to check 
\begin_inset Formula $n^{2}$
\end_inset

 edges total.
 This is polytime
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
Proof that COL is NP-Complete
\end_layout

\begin_layout Standard
WTS: 3COL
\begin_inset Formula $\leq_{P}$
\end_inset

 COL
\end_layout

\begin_layout Subsubsection
The construction
\end_layout

\begin_layout Standard
First, the trivial cases need to be put out of their misery: The case when
 k=1 is trivial: Unless the graph is empty or 1-vertex, it is false.
 And cases where k<1 are not worth considering.
 If k=2, this is the same thing as saying that every node has only two or
 less vertices leading out of it.
 This is polytime and not worth further consideration.
\end_layout

\begin_layout Standard
Now, building on the ideas in a previous piazza post, we are going to do
 our construction by first picking a 
\begin_inset Formula $k>2$
\end_inset

 out of a magic hat.
 Now, modulo k by the number of vertices.
 Then, let 
\begin_inset Formula $j=k-3$
\end_inset

.
 Now, add j new vertices, and connect the new vertices to every node in
 the graph.
 This will make it so that j of our k colors are taken, and the potentially-3-co
lorable graph in the middle must be 3-colorable for our input to be in COL
\end_layout

\begin_layout Subsubsection
The forward direction
\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $G\in\text{3COL}$
\end_inset

, let 
\begin_inset Formula $\left\langle G^{\prime},k\right\rangle =f(G)$
\end_inset

.
 Since G is a subgraph of 
\begin_inset Formula $G^{\prime}$
\end_inset

 and G is 3-colorable, we know that 
\begin_inset Formula $G^{\prime}$
\end_inset

 is k-colorable since we can assign the other j colors to j added nodes.
 
\end_layout

\begin_layout Subsubsection
The reverse direction
\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $G\not\in\text{3COL}$
\end_inset

, let 
\begin_inset Formula $\left\langle G^{\prime},k\right\rangle =f(G)$
\end_inset

.
 We know G is not 3-colorable so we must use extra colors to color in G.
 This implies that one of our j nodes must have the same color as a vertex
 in G.
 This implies that 
\begin_inset Formula $G^{\prime}$
\end_inset

 is not k-colorable
\end_layout

\begin_layout Subsubsection
Justification for polytimeness
\end_layout

\begin_layout Standard
This construction is polytime because pulling a magic number out of a hat
 is polytime if you hook up a turing machine to some uranium-235 as a hardware
 RNG source.
 Then, adding 
\begin_inset Formula $\mathcal{O}\left(k\right)$
\end_inset

 edges is 
\begin_inset Formula $n\cdot k$
\end_inset

 time, which is 
\begin_inset Formula $n^{2}$
\end_inset

 time since k is bound by n.
 Therefore, our construction is polytime
\end_layout

\end_body
\end_document
